/* Generated by Together */

#include "RanaTriggerBank.h"
#include "RanaSpace.h"
#include "RanaSpaceBank.h"
#include "RanaContext.h"

void RanaTriggerBank::clearTrackSetting()
{
	m_trackLogTrigger = true;
	m_lagLimit = 4;
}

RanaTriggerBank::RanaTriggerBank(RanaSpace& space,Trigger::TriggerSpace& triggerSystem)
	:m_pRanaSpace(&space)
	,m_triggerSystem(triggerSystem)
{
	clearTrackSetting();
}

RanaTriggerBank::~RanaTriggerBank()
{
	deleteAllTrigger();
}

void RanaTriggerBank::onMessage(RanaMessage *pMessage)
{
	m_triggerSystem.onMessage(pMessage);
}

// 添加一个触发器
int RanaTriggerBank::addTrigger(const RanaTriggerName& triggerName,RanaTrigger* pTriggerBase)
{
	if( !m_pRanaSpace->isInitialed() )
	{
		return -1;
	}
	if( pTriggerBase->getPossessingSpace() )
	{
		return -1;
	}
	if( strcmp(triggerName,"") == 0 )
	{
		return -1;
	}
	pTriggerBase->m_name = triggerName;
	std::map<RanaTriggerName,RanaTrigger*>::iterator itTriggerName = m_triggerNameMap.find(triggerName);
	if( itTriggerName != m_triggerNameMap.end() )
	{
		//该RanaSpace中已有相同名字的trigger
		pTriggerBase->m_handle = itTriggerName->second->getHandle();
		return -1;
	}
	/*//---------------------------------------------------------------S
	const char* const pFileBuf  = m_pRanaSpace->getLoadedFileBuff();
	if(!pFileBuf)
	{
		return -1;
	}
	*///---------------------------------------------------------------E
	RanaWORD handle = 0;
	if(!m_unusedTriggerHandle.size())
	{
		const RanaWORD maxHandle = ~0;
		if( m_triggersByHandle.size() >= maxHandle )
		{
			return -1;
		}
		handle = static_cast<RanaWORD>( m_triggersByHandle.size() );
		m_triggersByHandle.push_back(NULL);
	}
	else
	{
		handle = m_unusedTriggerHandle.front();
		m_unusedTriggerHandle.pop_front();
	}
	m_triggersByHandle[handle] = pTriggerBase;
	m_triggerNameMap[triggerName] = pTriggerBase;
	pTriggerBase->m_handle = handle;
	if( ! m_triggerSystem.possessAction(pTriggerBase) )
	{
		RANA_ASSERT(0);
	}
	pTriggerBase->setCustomContext( (Trigger::SpaceAction::ActionContext)getCustomContextForTriggerSystem() );

	if( getOwnerSpace().getHook() )
	{
		getOwnerSpace().getHook()->onTriggerAdded(pTriggerBase);
	}
	return 0;
}

// 删除一个触发器
int RanaTriggerBank::deleteTrigger(RanaWORD triggerHandle)
{
	RanaTrigger* pTrigger = getTrigger(triggerHandle);
	if(!pTrigger)
	{
		return -1;
	}
	while( pTrigger->getBindedEvents().size() )
	{
		std::vector<RanaEvent*> events;
		listEventByTrigger( triggerHandle, events );
		for(size_t i = 0; i<events.size(); ++i )
		{
			deleteEvent( events[i]->getHandle() );
		}
	}
	if( ! m_triggerSystem.releaseNonBindAction(pTrigger) )
	{
		RANA_ASSERT(0);
		return -1;
	}
	pTrigger->setCustomContext(NULL);
	m_triggersByHandle[triggerHandle] = NULL;
	m_triggerNameMap.erase(pTrigger->getName());
	m_unusedTriggerHandle.push_back(triggerHandle);


	if( getOwnerSpace().getHook() )
	{
		getOwnerSpace().getHook()->onTriggerRemoved(pTrigger);
	}
	delete pTrigger;
	return 0;
}

// 注册一个事件/触发器
int RanaTriggerBank::addEvent(const RanaEventName& eventName, RanaEvent* pEventBase)
{
	if( !getOwnerSpace().isInitialed() )
	{
		return -1;
	}
	if (!pEventBase)
	{
		return -1;
	}
	if(pEventBase->getPossessingSpace() )
	{
		return -1;
	}
	pEventBase->setCustomContext( (Trigger::SpaceEvent::EventContext)getCustomContextForTriggerSystem() );
	if(!strcmp(eventName,""))
	{
		return -1;
	}
	pEventBase->m_name = eventName;
	if(m_eventNameMap.find(eventName) != m_eventNameMap.end() )
	{
		return -1;
	}
	RanaWORD handle = 0;
	if(!m_unusedEventHandle.size())
	{
		const RanaWORD maxHandle = ~0;
		if( m_eventsByHandle.size() >= maxHandle )
		{
			return -1;
		}
		handle = static_cast<RanaWORD>( m_eventsByHandle.size() );
		m_eventsByHandle.push_back(NULL);
	}
	else
	{
		handle = m_unusedEventHandle.front();
		m_unusedEventHandle.pop_front();
	}
	pEventBase->m_handle = handle;
	RANA_ASSERT( getEvent(handle) == NULL );
	m_eventsByHandle[handle] = pEventBase;
	m_eventNameMap[eventName] = pEventBase;
	if( ! m_triggerSystem.possessEvent(pEventBase) )
	{
		RANA_ASSERT(0);
	}

	if( getOwnerSpace().getHook() )
	{
		getOwnerSpace().getHook()->onEventAdded(pEventBase);
	}

	return 0;
}

int RanaTriggerBank::deleteEvent( RanaWORD eventHandle )
{
	RanaEvent* pEvent = getEvent(eventHandle);
	if( !pEvent )
	{
		return -1;
	}
	while( pEvent->getBindedAction() )
	{
		m_triggerSystem.bindEventToAction(pEvent,NULL);
	}
	if( ! m_triggerSystem.releaseNonBindEvent(pEvent) )
	{
		RANA_ASSERT(0);
		return -1;
	}
	pEvent->setCustomContext(NULL);
	m_eventsByHandle[eventHandle] = NULL;
	m_eventNameMap.erase(pEvent->getName());
	m_unusedEventHandle.push_back(eventHandle);

	if( getOwnerSpace().getHook() )
	{
		getOwnerSpace().getHook()->onEventRemoved(pEvent);
	}
	delete pEvent;

	return 0;
}

int RanaTriggerBank::bindEvent(RanaWORD eventHandle,RanaWORD triggerHandle)
{
	RanaEvent* pEvent = getEvent(eventHandle);
	if(!pEvent)
	{
		return -1;
	}
	RanaTrigger* pTrigger = getTrigger(triggerHandle);
	if(!pTrigger)
	{
		return -1;
	}
	if( ! m_triggerSystem.bindEventToAction(pEvent,pTrigger) )
	{
		return -1;
	}
	return 0;
}

void RanaTriggerBank::deleteAllTrigger()
{
	deleteAllEvent();
	for(size_t i = 0; i< m_triggersByHandle.size(); ++i)
	{
		RanaTrigger* pTrigger = m_triggersByHandle[i];
		if(!pTrigger)
		{
			continue;
		}
		if( ! m_triggerSystem.releaseNonBindAction(pTrigger) )
		{
			RANA_ASSERT(0);
		}
		delete pTrigger;
		m_triggersByHandle[i] = NULL;
	}
	RANA_ASSERT(m_triggerSystem.listActions().empty());
	m_triggersByHandle.clear();
	m_unusedTriggerHandle.clear();
	m_triggerNameMap.clear();
}

void RanaTriggerBank::deleteAllEvent()
{
	for(size_t i = 0; i< m_eventsByHandle.size(); ++i)
	{
		RanaEvent* pEvent = m_eventsByHandle[i];
		if(!pEvent)
		{
			continue;
		}
		if( ! m_triggerSystem.bindEventToAction(pEvent,NULL) )
		{
			RANA_ASSERT(0);
		}
		if( ! m_triggerSystem.releaseNonBindEvent(pEvent) )
		{
			RANA_ASSERT(0);
		}
		delete pEvent;
		m_eventsByHandle[i] = NULL;
	}
	RANA_ASSERT(m_triggerSystem.listEvents().empty());
	m_eventsByHandle.clear();
	m_unusedEventHandle.clear();
	m_eventNameMap.clear();
}

//2006-09-19 触发器状态统计：收到消息
bool RanaTriggerBank::tagMessageCount(RanaWORD triggerHandle)
{
	if(!this)
	{
		return false;
	}
	RanaTrigger* pTrigger = getTrigger(triggerHandle);
	if(!pTrigger)
	{
		//没有找到合适的trigger
		return false;
	}

	if(m_trackLogTrigger && RanaSpaceBank::getInstance()->isAllowTrackTrigger() )
	{
		pTrigger->getTriggerStat()->countM();
	}
	return true;
}

void RanaTriggerBank::listTriggers(std::vector<RanaTrigger*>& output)
{
	for(size_t i = 0; i< m_triggersByHandle.size(); ++i)
	{
		RanaTrigger* pTrigger = m_triggersByHandle[i];
		if(!pTrigger)
		{
			continue;
		}
		output.push_back(pTrigger);
	}
}

void RanaTriggerBank::listEvents(std::vector<RanaEvent*>& output)
{
	for(size_t i = 0; i< m_eventsByHandle.size(); ++i)
	{
		RanaEvent* pEvent = m_eventsByHandle[i];
		if(!pEvent)
		{
			continue;
		}
		output.push_back(pEvent);
	}
}

void RanaTriggerBank::listEventByTrigger(RanaWORD triggerHandle,std::vector<RanaEvent*>& output)
{
	RanaTrigger* pTrigger = getTrigger(triggerHandle);
	if(!pTrigger)
	{
		return;
	}
	const std::set<Trigger::SpaceEvent*>& eventSet = pTrigger->getBindedEvents();
	std::set<Trigger::SpaceEvent*>::const_iterator itEvent=eventSet.begin();
	for(;itEvent!=eventSet.end();++itEvent)
	{
		output.push_back(static_cast<RanaEvent*>(*itEvent));
	}
}

void RanaTriggerBank::listEventByType(RanaEventType eventType, std::vector<RanaEvent*>& output)
{
	std::vector<Trigger::SpaceEvent*> orgResult; 
	m_triggerSystem.collectAllEventsByType(eventType,orgResult);
	for(size_t i = 0; i< orgResult.size(); ++i)
	{
		RanaEvent* pEvent = static_cast<RanaEvent*>(orgResult[i]);
		output.push_back(pEvent);
	}
}

RanaTrigger* RanaTriggerBank::getTrigger(RanaWORD triggerHandle)
{
	if( triggerHandle >= m_triggersByHandle.size() )
	{
		return NULL;
	}
	return m_triggersByHandle[triggerHandle];
}

RanaTrigger* RanaTriggerBank::getTrigger(const RanaTriggerName& triggerName)
{
	std::map<RanaTriggerName,RanaTrigger*>::iterator it = m_triggerNameMap.find(triggerName);
	if( it == m_triggerNameMap.end())
	{
		//没有找到合适的trigger
		return NULL;
	}
	return it->second;
}

RanaEvent* RanaTriggerBank::getEvent( RanaWORD eventHandle)
{
	if( eventHandle >= m_eventsByHandle.size() )
	{
		return NULL;
	}
	return m_eventsByHandle[eventHandle];
}

RanaEvent* RanaTriggerBank::getEvent( const RanaEventName& eventName)
{
	std::map<RanaEventName,RanaEvent*>::iterator itEvent = m_eventNameMap.find(eventName);
	if( itEvent == m_eventNameMap.end() )
	{
		return NULL;
	}
	return itEvent->second;
}

void RanaTriggerBank::clear()
{
	deleteAllEvent();
	deleteAllTrigger();
#ifdef _DEBUG
	m_triggerSystem.~TriggerSpace();
	new (&m_triggerSystem) Trigger::TriggerSpace();
#endif
}

bool RanaTriggerBank::isTrackLogTrigger() const
{
	return m_trackLogTrigger && RanaSpaceBank::getInstance()->isAllowTrackTrigger();
}
