#pragma warning(disable:4996)

/* Generated by Together */

#include "RanaTrigger.h"
#include "RanaSpaceBank.h"
#include "RanaSpace.h"
#include "RanaContext.h"
#include <string>

namespace
{
	static const char* const pFuncHead = "function ";
	static const char* const pConditionHead = "_Conditions";
	static const char* const pActionHead = "_Actions";
	static const char* const pFuncStart = "()\n";
	static const char* const pFuncEnd = "\nend";
	static const char* const pFuncClean = " = nil;\n";
	static const char* const pEmptyCondition = "return true;";
	static const char* const pEmptyAction = "";
}

RanaTrigger::RanaTrigger()
	:m_triggerStat(NULL)
{
	m_isOn = false;
//	m_pConditionContent = "";
//	m_pActionContent = "";
}

RanaTrigger::~RanaTrigger()
{
	if(m_triggerStat)
	{
		delete m_triggerStat;
		m_triggerStat = NULL;
	}
}

RanaTriggerStat* RanaTrigger::getTriggerStat()
{
	if( !m_triggerStat )
	{
		m_triggerStat = new RanaTriggerStat;
	}
	return m_triggerStat;
}

void RanaTrigger::setName(const RanaTriggerName &_name)
{
	m_name = _name;
}

const RanaTriggerName &RanaTrigger::getName()
{
	return m_name;
}

void RanaTrigger::setOnOff(bool _isOn)
{
	m_isOn = _isOn;
}

bool RanaTrigger::getOnOff()
{
	return m_isOn;
}

static const int APPEND_MAX_LEN = 32;
bool RanaTrigger::checkCondition()
{
	char funcName[sizeof(m_name)+APPEND_MAX_LEN];
	m_name.data(funcName);
	strcat(funcName,pConditionHead);
	bool res;
	RanaSpace* pSelfSpace = getSelfSpace();
	if(pSelfSpace == NULL)
	{
		debug_ranaLog("RanaTrigger::No Self Space Init, Can not run Condition!");
		return false;
	}

	int ret = pSelfSpace->runFunction(funcName,&res) ;
	if(ret != RanaSpace::RESULT_OK)
	{
		ranaError("Error While Space[Handle(%d,%d)\"%s\"] Running \"%s\" Condition! (Base File: \"%s\")!",
			pSelfSpace->getHandle().handle,pSelfSpace->getHandle().serial,pSelfSpace->getSpaceName().name,
			getName().name ,pSelfSpace->getFileName() );

		if(ret == RanaSpace::ERROR_NO_SUCH_FUNCTION)
		{
			return true;
		}
		return false;
	}
	return res;
}

bool RanaTrigger::doAction()
{
	RanaSpace* pSpace = getSelfSpace();
	if(!pSpace)
	{
		RANA_ASSERT(0);
		return false;
	}
	if( !getOnOff() )
	{
		return false;
	}
	RanaTriggerBank* pSelfOwner = pSpace->getTriggerBank();
	RanaContext* pRanaContext = pSpace->getContext();
	if( pRanaContext )
	{
		pRanaContext->onBeforeBurstTrigger(pSpace,this);

		//extra Prevalidate
		if( !pRanaContext->onTriggerEventHit(pSpace,this) )
		{
			pRanaContext->onAfterBurstTrigger(pSpace,this);
			return false;
		}
	}
	RanaTriggerStat* pTriggerStat = NULL;
	
	if( pSpace->getTriggerBank()->isTrackLogTrigger() )
	{
		pTriggerStat = getTriggerStat();
	}
	if(pTriggerStat)
	{
		pTriggerStat->ConditionStart();
	}
	bool isConditionSuccess = checkCondition();
	if( isConditionSuccess && pRanaContext )
	{
		isConditionSuccess = pRanaContext->onTriggerConditionSuccess(pSpace,this);
	}
	if(pTriggerStat)
	{
		pTriggerStat->ConditionOver();
		pTriggerStat->countMeca();	//2006-09-19 通过了Condtion检测并执行了Action
	}
	if(isConditionSuccess)
	{
		if(pTriggerStat)
		{
//*2006-09-20 测试用，打印此次调用进行Condition检查的花费时间
//			debug_ranaLog(" ( No.%d: \"%s\" Successed in Condition, Cost:%d )",pTriggerStat->getMecaCount(), pTrigger->getName().name, pTriggerStat->getLastConditionTime());
//*/
			pTriggerStat->ActionStart();
		}
		directDoAction();

		if(pTriggerStat)
		{
			pTriggerStat->ActionOver();
//*2006-09-20 测试用，打印此次调用进行Action执行的花费时间
			if( pSelfOwner->getLagLimit() > 0 && pTriggerStat->getLastConditionTime() + pTriggerStat->getLastActionTime() > pSelfOwner->getLagLimit() )
			{
				ranaLog(" ( ------Warning!------ Handle:%d\"%s\"(%d): \"%s\" run Action, Cost:<Condition>%d,<Action>%d Over Limit ! (Base File: \"%s\")! )",
					pSpace->getHandle().handle,pSpace->getSpaceName().name,pTriggerStat->getMecaCount(), getName().name,pTriggerStat->getLastConditionTime(),pTriggerStat->getLastActionTime(),pSpace->getFileName() );
			}
			ranaLog(" ( Handle:%d(%d): \"%s\" run Action, Cost:<Condition>%d,<Action>%d )",pSpace->getHandle().handle,pTriggerStat->getMecaCount(), getName().name,pTriggerStat->getLastConditionTime(),pTriggerStat->getLastActionTime() );
//*/
		}
	}
	else
	{
		if(pTriggerStat)
		{
//*2006-09-20 测试用，打印此次调用进行Condition检查的花费时间
			if( pSelfOwner->getLagLimit() > 0 && pTriggerStat->getLastConditionTime() > pSelfOwner->getLagLimit())
			{
				ranaLog(" ( ------Warning!------ Handle:%d\"%s\"(%d): \"%s\" failed in Condition, Cost:%d Over Limit ! (Base File: \"%s\")!)",
					pSpace->getHandle().handle,pSpace->getSpaceName().name, pTriggerStat->getMecCount(), getName().name,pTriggerStat->getLastConditionTime(),pSpace->getFileName() );
			}
			debug_ranaLog(" ( Handle:%d(%d): \"%s\" failed in Condition, Cost:%d )",pSpace->getHandle().handle, pTriggerStat->getMecCount(), getName().name,pTriggerStat->getLastConditionTime());
//*/
		}
	}
	pRanaContext = pSpace->getContext();
	if( pRanaContext )
	{
		pRanaContext->onAfterBurstTrigger(pSpace,this);
	}
	return true;
}

bool RanaTrigger::doAction(Trigger::SpaceEvent* pTriggerEvent)
{
	return doAction();
}

void RanaTrigger::directDoAction()
{
	char funcName[sizeof(m_name)+APPEND_MAX_LEN];
	m_name.data(funcName);
	strcat(funcName,pActionHead);

	RanaSpace* pSelfSpace = getSelfSpace();
	if(pSelfSpace == NULL)
	{
		debug_ranaLog("RanaTrigger::No Self Space Init, Can not run Action");
		return;
	}

	if( pSelfSpace->runFunction(funcName) != RanaSpace::RESULT_OK )
	{
		ranaError("Error While Space[Handle(%d,%d)\"%s\"] Running \"%s\" Action! (Base File: \"%s\")!",
			pSelfSpace->getHandle().handle,pSelfSpace->getHandle().serial,pSelfSpace->getSpaceName().name,
			getName().name ,pSelfSpace->getFileName() );

		return;//failed
	}
	return;
}

RanaSpace* RanaTrigger::getSelfSpace() const
{
	RanaSpace* const * ppSpace = (RanaSpace*const*)getCustomContext();
	return ppSpace ? *ppSpace : NULL;
}

int RanaTrigger::setRanaScriptCondition(RanaSpace* pSpace,const char* pTriggerName,const char* conditionDetail)
{
	std::string runBuffer;
	runBuffer += pFuncHead;
	runBuffer += pTriggerName;
	runBuffer += pConditionHead;
	runBuffer += pFuncStart;
	runBuffer += conditionDetail;
	runBuffer += pFuncEnd;
	return pSpace->runBuf(runBuffer.c_str() );
}

int RanaTrigger::setRanaScriptAction(RanaSpace* pSpace,const char* pTriggerName,const char* actionDetail)
{
	std::string runBuffer;
	runBuffer += pFuncHead;
	runBuffer += pTriggerName;
	runBuffer += pActionHead;
	runBuffer += pFuncStart;
	runBuffer += actionDetail;
	runBuffer += pFuncEnd;
	return pSpace->runBuf(runBuffer.c_str() );
}

int RanaTrigger::cleanRanaScriptCondition(RanaSpace* pSpace,const char* pTriggerName)
{
	return setRanaScriptCondition(pSpace,pTriggerName,pEmptyCondition);
}

int RanaTrigger::cleanRanaScriptAction(RanaSpace* pSpace,const char* pTriggerName)
{
	return setRanaScriptAction(pSpace,pTriggerName,pEmptyAction);
}

int RanaTrigger::deleteRanaScriptCondition(RanaSpace* pSpace,const char* pTriggerName)
{
	std::string runBuffer;
	runBuffer+=pTriggerName;
	runBuffer+=pConditionHead;
	runBuffer+=pFuncClean;
	return pSpace->runBuf(runBuffer.c_str() );
}

int RanaTrigger::deleteRanaScriptAction(RanaSpace* pSpace,const char* pTriggerName)
{
	std::string runBuffer;
	runBuffer+=pTriggerName;
	runBuffer+=pActionHead;
	runBuffer+=pFuncClean;
	return pSpace->runBuf(runBuffer.c_str() );
}

